import os
import json
import logging
import asyncio
from datetime import datetime, time, timedelta, timezone

import discord
from discord.ext import commands, tasks
import google.generativeai as genai
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import dropbox
from dropbox.exceptions import ApiError
from dropbox.files import WriteMode, DownloadError

from utils.obsidian_utils import update_section

# --- å®šæ•°å®šç¾© ---
JST = timezone(timedelta(hours=+9), 'JST')
ALL_DAY_SCHEDULE_TIME = time(hour=7, minute=0, tzinfo=JST)
TOMORROW_SCHEDULE_TIME = time(hour=21, minute=0, tzinfo=JST)
DAILY_REVIEW_TIME = time(hour=22, minute=0, tzinfo=JST)

# Google Calendar APIã®ã‚¹ã‚³ãƒ¼ãƒ—
SCOPES = ['https://www.googleapis.com/auth/calendar.readonly']

class CalendarCog(commands.Cog):
    """
    Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã¨é€£æºã—ã€ã‚¿ã‚¹ã‚¯ç®¡ç†ã‚’è‡ªå‹•åŒ–ã™ã‚‹Cog
    """
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.is_ready = False
        self._load_environment_variables()
        if not self._are_credentials_valid():
            logging.error("CalendarCog: å¿…é ˆã®ç’°å¢ƒå¤‰æ•°ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ã“ã®Cogã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¾ã™ã€‚")
            return
        try:
            self.creds = self._get_google_credentials()
            if not self.creds:
                logging.error("CalendarCog: Google Calendarã®èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚")
                return
            genai.configure(api_key=self.gemini_api_key)
            self.gemini_model = genai.GenerativeModel("gemini-2.5-pro")
            self.dbx = self._initialize_dropbox_client()
            self.is_ready = True
            logging.info("âœ… CalendarCogãŒæ­£å¸¸ã«åˆæœŸåŒ–ã•ã‚Œã€æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸã€‚")
        except Exception as e:
            logging.error(f"âŒ CalendarCogã®åˆæœŸåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}", exc_info=True)

    def _load_environment_variables(self):
        self.calendar_channel_id = int(os.getenv("CALENDAR_CHANNEL_ID", 0))
        self.gemini_api_key = os.getenv("GEMINI_API_KEY")
        self.dropbox_app_key = os.getenv("DROPBOX_APP_KEY")
        self.dropbox_app_secret = os.getenv("DROPBOX_APP_SECRET")
        self.dropbox_refresh_token = os.getenv("DROPBOX_REFRESH_TOKEN")
        self.dropbox_vault_path = os.getenv("DROPBOX_VAULT_PATH")
        self.google_credentials_path = os.getenv("GOOGLE_CREDENTIALS_PATH", "credentials.json")
        self.google_token_path = os.getenv("GOOGLE_TOKEN_PATH", "token.json")

    def _are_credentials_valid(self) -> bool:
        return all([
            self.calendar_channel_id, self.gemini_api_key, self.dropbox_refresh_token,
            self.dropbox_vault_path, self.google_credentials_path, self.google_token_path
        ])

    def _initialize_dropbox_client(self) -> dropbox.Dropbox:
        return dropbox.Dropbox(
            app_key=self.dropbox_app_key,
            app_secret=self.dropbox_app_secret,
            oauth2_refresh_token=self.dropbox_refresh_token
        )

    def _get_google_credentials(self):
        creds = None
        if os.path.exists(self.google_token_path):
            creds = Credentials.from_authorized_user_file(self.google_token_path, SCOPES)
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                try:
                    creds.refresh(Request())
                except Exception as e:
                    logging.error(f"Googleãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
                    os.remove(self.google_token_path)
                    return self._get_google_credentials()
            else:
                if not os.path.exists(self.google_credentials_path):
                    logging.error(f"{self.google_credentials_path} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
                    return None
                flow = InstalledAppFlow.from_client_secrets_file(self.google_credentials_path, SCOPES)
                creds = flow.run_local_server(port=0)
            with open(self.google_token_path, 'w') as token:
                token.write(creds.to_json())
        return creds

    @commands.Cog.listener()
    async def on_ready(self):
        if self.is_ready:
            if not self.notify_upcoming_events.is_running(): self.notify_upcoming_events.start()
            if not self.notify_all_day_events.is_running(): self.notify_all_day_events.start()
            if not self.notify_tomorrow_events.is_running(): self.notify_tomorrow_events.start()
            if not self.send_daily_review.is_running(): self.send_daily_review.start()

    def cog_unload(self):
        self.notify_upcoming_events.cancel()
        self.notify_all_day_events.cancel()
        self.notify_tomorrow_events.cancel()
        self.send_daily_review.cancel()

    # --- 1. ç›´è¿‘ã®äºˆå®šã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥ ---
    @tasks.loop(minutes=15)
    async def notify_upcoming_events(self):
        # (å‡¦ç†å†…å®¹ã¯å¤‰æ›´ãªã—)
        pass

    # --- 2. çµ‚æ—¥ã®äºˆå®šã‚’é€šçŸ¥ (æ–°è¦) ---
    @tasks.loop(time=ALL_DAY_SCHEDULE_TIME)
    async def notify_all_day_events(self):
        logging.info("[CalendarCog] æœ¬æ—¥ã®çµ‚æ—¥ã®äºˆå®šã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™...")
        try:
            today = datetime.now(JST).date()
            time_min_dt = datetime.combine(today, time.min, tzinfo=JST)
            time_max_dt = datetime.combine(today, time.max, tzinfo=JST)

            service = build('calendar', 'v3', credentials=self.creds)
            events_result = service.events().list(
                calendarId='primary', timeMin=time_min_dt.isoformat(), timeMax=time_max_dt.isoformat(),
                singleEvents=True, orderBy='startTime'
            ).execute()
            
            all_day_events = [e for e in events_result.get('items', []) if 'date' in e.get('start', {})]

            if not all_day_events:
                logging.info("[CalendarCog] æœ¬æ—¥ã®çµ‚æ—¥ã®äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
                return

            channel = self.bot.get_channel(self.calendar_channel_id)
            if not channel: return

            for event in all_day_events:
                embed = discord.Embed(
                    title=f"ğŸ—“ï¸ ä»Šæ—¥ã®äºˆå®š: {event.get('summary', 'åç§°æœªè¨­å®š')}",
                    description="æœ¬æ—¥ãŒæœŸæ—¥ã®ã‚¿ã‚¹ã‚¯ã§ã™ã€‚",
                    color=discord.Color.orange()
                )
                await channel.send(embed=embed)
                await self._add_to_daily_log(event)

        except Exception as e:
            logging.error(f"[CalendarCog] çµ‚æ—¥ã®äºˆå®šé€šçŸ¥ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)

    # --- 3. æ˜æ—¥ã®äºˆå®šã®äº‹å‰é€šçŸ¥ ---
    @tasks.loop(time=TOMORROW_SCHEDULE_TIME)
    async def notify_tomorrow_events(self):
        pass

    # --- 4. ä¸€æ—¥ã®æŒ¯ã‚Šè¿”ã‚Šæ©Ÿèƒ½ ---
    @tasks.loop(time=DAILY_REVIEW_TIME)
    async def send_daily_review(self):
        logging.info("[CalendarCog] ä¸€æ—¥ã®æŒ¯ã‚Šè¿”ã‚Šé€šçŸ¥ã‚¿ã‚¹ã‚¯ã‚’é–‹å§‹ã—ã¾ã™...")
        try:
            today_str = datetime.now(JST).strftime('%Y-%m-%d')
            log_path = f"{self.dropbox_vault_path}/.bot/calendar_log/{today_str}.json"
            
            try:
                _, res = self.dbx.files_download(log_path)
                daily_events = json.loads(res.content.decode('utf-8'))
            except ApiError as e:
                if isinstance(e.error, DownloadError) and e.error.is_path() and e.error.get_path().is_not_found():
                    logging.info(f"[CalendarCog] {today_str} ã®é€šçŸ¥ãƒ­ã‚°ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
                    return
                raise

            if not daily_events: return

            channel = self.bot.get_channel(self.calendar_channel_id)
            if channel:
                await channel.send(f"--- **ğŸ—“ï¸ {today_str} ã®ã‚¿ã‚¹ã‚¯ãƒ¬ãƒ“ãƒ¥ãƒ¼** ---\nãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼ä»Šæ—¥ã®ã‚¿ã‚¹ã‚¯ã®é”æˆåº¦ã‚’ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§æ•™ãˆã¦ãã ã•ã„ã€‚")
                for event in daily_events:
                    embed = discord.Embed(
                        title=f"ã‚¿ã‚¹ã‚¯: {event['summary']}",
                        color=discord.Color.gold()
                    )
                    message = await channel.send(embed=embed)
                    await message.add_reaction("âœ…")
                    await message.add_reaction("âŒ")
                await channel.send("--------------------")
        except Exception as e:
            logging.error(f"[CalendarCog] æŒ¯ã‚Šè¿”ã‚Šé€šçŸ¥ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)

    # --- 5. é€²æ—ã®è¨˜éŒ² ---
    @commands.Cog.listener()
    async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
        if payload.user_id == self.bot.user.id or payload.channel_id != self.calendar_channel_id:
            return
        try:
            channel = self.bot.get_channel(payload.channel_id)
            message = await channel.fetch_message(payload.message_id)
            if message.author.id != self.bot.user.id or not message.embeds: return
            
            embed = message.embeds[0]
            if not embed.title or not embed.title.startswith("ã‚¿ã‚¹ã‚¯: "): return

            task_summary = embed.title.replace("ã‚¿ã‚¹ã‚¯: ", "")
            today_str = datetime.now(JST).strftime('%Y-%m-%d')
            target_date = datetime.strptime(today_str, '%Y-%m-%d').date()

            task_list_md = f"- [{ 'x' if str(payload.emoji) == 'âœ…' else ' ' }] {task_summary}\n"
            await self._update_obsidian_task_log(target_date, task_list_md)
            
            user = self.bot.get_user(payload.user_id)
            if user:
                await message.remove_reaction(payload.emoji, user)
            
            feedback_msg = await channel.send(f"{user.mention}ã•ã‚“ã€ã€Œ{task_summary}ã€ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼", delete_after=10)
            await message.delete(delay=10)

        except (discord.NotFound, discord.Forbidden): pass
        except Exception as e:
            logging.error(f"[CalendarCog] ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)

    # --- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
    async def _generate_event_advice(self, event: dict) -> str:
        # ã“ã®é–¢æ•°ã¯ç›´è¿‘ã®äºˆå®šé€šçŸ¥ã§ã¯ä½¿ã‚ã‚Œãªããªã‚‹
        return "ç›´å‰ã®ç¢ºèªã‚’æ€ ã‚‰ãšã€æº–å‚™ã‚’ä¸‡å…¨ã«ã—ã¾ã—ã‚‡ã†ã€‚"

    async def _generate_overall_advice(self, events: list) -> str:
        event_list_str = ""
        for event in events:
            start = self._format_datetime(event.get('start'))
            event_list_str += f"- {start}: {event.get('summary', 'åç§°æœªè¨­å®š')}\n"
        prompt = f"""
        ä»¥ä¸‹ã®æ˜æ—¥ã®äºˆå®šãƒªã‚¹ãƒˆå…¨ä½“ã‚’è¦‹ã¦ã€ä¸€æ—¥ã‚’æœ€ã‚‚ç”Ÿç”£çš„ã«éã”ã™ãŸã‚ã®ç·åˆçš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚
        # æŒ‡ç¤º
        - æŒ¨æ‹¶ã‚„å‰ç½®ãã¯ä¸è¦ã§ã™ã€‚
        - ç®‡æ¡æ›¸ãã§ã€ç°¡æ½”ã«3ç‚¹ã»ã©ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
        # æ˜æ—¥ã®äºˆå®šãƒªã‚¹ãƒˆ
        {event_list_str}
        """
        try:
            response = await self.gemini_model.generate_content_async(prompt)
            return response.text
        except Exception as e:
            logging.error(f"ç·åˆã‚¢ãƒ‰ãƒã‚¤ã‚¹ã®ç”Ÿæˆã«å¤±æ•—: {e}")
            return "ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    # ä»–ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° (_create_event_embed, _create_tomorrow_embed, _format_datetime, etc.) ã¯å¤‰æ›´ãªã—
    pass